<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>Mosquito Finder</title>
  <meta name="theme-color" content="#02304c" />
  <style>
    :root { --brand-dark:#02304c; --brand-light:#bae5e5; }
    html, body { height:100%; margin:0; background:var(--brand-dark); color:#fff; font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif; }
    .wrap { position:relative; width:100%; height:100%; overflow:hidden; }
    video, canvas { position:absolute; inset:0; width:100%; height:100%; object-fit:cover; }
    .glass { position:fixed; inset:auto 0 0 0; padding:16px; display:flex; gap:12px; justify-content:center;
             background:linear-gradient(180deg, rgba(2,48,76,0) 0%, rgba(2,48,76,.65) 60%, rgba(2,48,76,.95) 100%); }
    button { padding:12px 16px; border:0; border-radius:14px; font-weight:700; background:var(--brand-light); color:var(--brand-dark); }
    #status { position:fixed; top:10px; left:12px; right:12px; font-size:14px; opacity:.95; }
    .title { position:fixed; top:10px; left:12px; font-weight:800; color:var(--brand-light); text-shadow:0 1px 0 rgba(0,0,0,.4); }
    .hint { position:fixed; top:36px; left:12px; font-size:12px; opacity:.85; }
    .perm { position:absolute; inset:0; display:none; align-items:center; justify-content:center; text-align:center; padding:24px; }
    .card { background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.2); backdrop-filter:blur(6px);
            border-radius:16px; padding:18px; max-width:520px; }
    .card h2 { margin:0 0 8px 0; color:var(--brand-light); }
    .card p { margin:0 0 14px 0; color:#e6f6f6; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="title">ðŸ¦Ÿ Mosquito Finder</div>
    <div id="status">Ready</div>
    <div class="hint">Tip: point at a bright, plain wall for best results.</div>

    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>

    <div id="perm" class="perm">
      <div class="card">
        <h2>Camera access needed</h2>
        <p>We only use your camera locally to highlight tiny motion. Nothing is uploaded.</p>
        <button id="startBtn">Enable Camera</button>
      </div>
    </div>

    <div class="glass">
      <button id="flashBtn">Toggle Flashlight</button>
      <button id="scanBtn">Scan Area Again</button>
    </div>
  </div>

  <script>
    const video = document.getElementById('video');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const startBtn = document.getElementById('startBtn');
    const flashBtn = document.getElementById('flashBtn');
    const scanBtn = document.getElementById('scanBtn');
    const statusEl = document.getElementById('status');
    const perm = document.getElementById('perm');

    let stream = null;
    let torchOn = false;
    let previousFrame = null;
    let lastMotionTime = 0;
    let rafId = null;

    function setStatus(msg){ statusEl.textContent = msg; }

    // Show permission card on load (iOS requires user gesture before getUserMedia)
    document.addEventListener('DOMContentLoaded', () => {
      perm.style.display = 'flex';
    });

    async function startCamera(){
      try{
        setStatus('Requesting camera accessâ€¦');
        stream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: { ideal: 'environment' }, width:{ ideal:1280 }, height:{ ideal:720 } },
          audio: false
        });
        perm.style.display = 'none';
        video.srcObject = stream;
        await video.play();
        // Size canvas to actual video size
        function size(){
          overlay.width = video.videoWidth || overlay.clientWidth;
          overlay.height = video.videoHeight || overlay.clientHeight;
        }
        size();
        window.addEventListener('resize', size);
        setStatus('Camera started. Scanning for tiny motionâ€¦');
        detectMotion();
      }catch(err){
        console.error(err);
        perm.style.display = 'flex';
        setStatus('Camera access failed. On iOS, open in Safari/Chrome and allow camera in the prompt.');
      }
    }

    async function toggleFlash(){
      try{
        if(!stream){ return setStatus('Start camera first.'); }
        const [track] = stream.getVideoTracks();
        const caps = track.getCapabilities ? track.getCapabilities() : {};
        if(!('torch' in caps)){
          return setStatus('Flashlight not supported in this browser (usually Android Chrome only).');
        }
        torchOn = !torchOn;
        await track.applyConstraints({ advanced: [{ torch: torchOn }] });
        setStatus(torchOn ? 'Flashlight ON' : 'Flashlight OFF');
      }catch(e){
        console.error(e);
        setStatus('Could not toggle flashlight.');
      }
    }

    function scanAgain(){
      previousFrame = null;
      lastMotionTime = 0;
      ctx.clearRect(0,0,overlay.width,overlay.height);
      setStatus('Scanning area againâ€¦');
    }

    // Simple frame-diff motion detector (downscaled for performance)
    function detectMotion(){
      const tmp = document.createElement('canvas');
      const tctx = tmp.getContext('2d');
      const scale = 0.25; // quarter-res
      function step(){
        if(video.readyState === 4){
          const w = Math.floor((video.videoWidth||overlay.width) * scale);
          const h = Math.floor((video.videoHeight||overlay.height) * scale);
          if(w && h){
            tmp.width = w; tmp.height = h;
            tctx.drawImage(video, 0, 0, w, h);
            const cur = tctx.getImageData(0,0,w,h);
            if(previousFrame){
              const th = 40; // sensitivity threshold
              const pts = [];
              for(let i=0;i<cur.data.length;i+=4){
                const d = Math.abs(cur.data[i]-previousFrame.data[i]) +
                          Math.abs(cur.data[i+1]-previousFrame.data[i+1]) +
                          Math.abs(cur.data[i+2]-previousFrame.data[i+2]);
                if(d>th){ // candidate motion pixel
                  const idx = i/4;
                  const x = (idx % w);
                  const y = Math.floor(idx / w);
                  pts.push([x,y]);
                }
              }
              // Draw highlights (very lightweight clustering by sampling every Nth point)
              ctx.clearRect(0,0,overlay.width,overlay.height);
              const stepPts = Math.max(1, Math.floor(pts.length/200)); // cap draws
              for(let j=0; j<pts.length; j+=stepPts){
                const [mx,my]=pts[j];
                const sx = (mx / w) * overlay.width;
                const sy = (my / h) * overlay.height;
                ctx.beginPath();
                ctx.arc(sx, sy, 10, 0, Math.PI*2);
                ctx.strokeStyle = 'rgba(186,229,229,.9)';
                ctx.lineWidth = 2;
                ctx.stroke();
              }
              if(pts.length>200){
                lastMotionTime = Date.now();
                setStatus('Motion detected ' + Math.max(1, Math.floor(pts.length/500)) + 'Ã—');
              }
            }
            previousFrame = cur;
          }
        }
        rafId = requestAnimationFrame(step);
      }
      step();
    }

    startBtn.addEventListener('click', startCamera);
    flashBtn.addEventListener('click', toggleFlash);
    scanBtn.addEventListener('click', scanAgain);
  </script>
</body>
</html>
